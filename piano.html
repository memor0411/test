<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>가상 피아노</title>
<style>
  body {
    background: #222;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    color: white;
    font-family: sans-serif;
  }

  .controls {
    margin-bottom: 20px;
  }

  button {
    margin: 4px;
    padding: 8px 12px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    background: #555;
    color: white;
  }

  button.active {
    background: #2ecc71;
  }

  .piano {
    position: relative;
    /* display:flex; 기존 CSS는 그대로 유지되지만 아래 JS에서 inline style으로 재정의하여 정상 배치합니다 */
  }

  .white {
    width: 60px;
    height: 240px;
    background: white;
    border: 1px solid #000;
    z-index: 1;
    box-shadow: inset -2px 0 3px rgba(0,0,0,0.3);
  }

  .black {
    width: 40px;
    height: 150px;
    background: black;
    position: absolute;
    top: 0;
    z-index: 2;
    margin-left: -20px;
    border: 1px solid #111;
  }

  .key.playing { background: #ddd; }
  .black.playing { background:#333; }

  .note-label {
    position: absolute;
    left: 50%;
    bottom: 6px;
    transform: translateX(-50%);
    font-size: 12px;
    color: #333;
  }
</style>
</head>
<body>

  <div class="controls">
    <button id="startAudio">피아노 시작하기</button>
    <button id="majorBtn" class="active">장조</button>
    <button id="minorBtn">단조</button>
    <button id="code1Btn" class="active">코드 1</button>
    <button id="code2Btn">코드 2</button>
  </div>

  <div class="piano" id="piano"></div>

<script>
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
let isStarted = false;
let scaleType = 'major';
let codeType = 1;

const BASE_URL = "https://gleitz.github.io/midi-js-soundfonts/FluidR3_GM/acoustic_grand_piano-mp3/";
const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const OCTAVES = [4,5];

const audioBuffers = {};

function noteToFile(note) {
  return note.replace('#', 's');
}

async function loadNote(note, octave) {
  const key = note + octave;
  if (audioBuffers[key]) return;
  const url = `${BASE_URL}${noteToFile(note)}${octave}.mp3`;
  try {
    const res = await fetch(url);
    const arr = await res.arrayBuffer();
    const buf = await audioCtx.decodeAudioData(arr);
    audioBuffers[key] = buf;
    console.log("로드 성공:", key);
  } catch (err) {
    console.error("로드 실패:", key, url);
  }
}

async function preload() {
  const promises = [];
  for (let o of OCTAVES) {
    for (let n of NOTES) {
      promises.push(loadNote(n, o));
    }
  }
  await Promise.all(promises);
  console.log("모든 음 로드 완료");
}

function playChord(note) {
  const idx = NOTES.indexOf(note);
  if (idx < 0) return;

  // 코드 구조
  const major = [0, 4, 7];
  const minor = [0, 3, 7];
  const pattern = scaleType === 'major' ? major : minor;

  pattern.forEach(interval => {
    let noteIndex = (idx + interval) % NOTES.length;
    let octaveShift = Math.floor((idx + interval) / NOTES.length);
    let octave = 4 + octaveShift;
    const noteName = NOTES[noteIndex];
    const key = noteName + octave;
    if (audioBuffers[key]) {
      const src = audioCtx.createBufferSource();
      src.buffer = audioBuffers[key];
      src.connect(audioCtx.destination);
      src.start();
    } else {
      console.warn("음원 없음:", key);
    }
  });
}

/* ---------------------------
   변경된 부분: createPiano
   - 도(C)에서 시작해서 도(C)로 끝나도록 (두 옥타브 + 상위 C 포함)
   - 화이트키 15개 (C4..B5 + C6), 블랙키는 각 옥타브 내부에 올바른 위치에 절대 배치
   - 다른 기존 코드(재생/로딩/버튼)는 건드리지 않음
   --------------------------- */
function createPiano() {
  const piano = document.getElementById("piano");
  piano.innerHTML = "";

  // white notes per octave
  const whiteNotes = ['C','D','E','F','G','A','B'];
  const blackPattern = ['C#','D#', null, 'F#','G#','A#', null];

  // build list of white keys: two octaves (4,5) plus top C (6)
  const whiteKeys = [];
  for (let o = 4; o <= 5; o++) {
    for (const wn of whiteNotes) {
      whiteKeys.push({ note: wn, octave: o });
    }
  }
  // add final top C (to end on '도')
  whiteKeys.push({ note: 'C', octave: 6 });

  // set container to absolute-layout mode so left offsets work
  const totalWhite = whiteKeys.length;
  piano.style.display = 'block'; // override CSS flex to allow absolute layout
  piano.style.width = (totalWhite * 60) + 'px';
  piano.style.height = '240px';
  piano.style.position = 'relative';

  // create white keys (absolute positioned)
  whiteKeys.forEach((k, i) => {
    const w = document.createElement('div');
    w.classList.add('key', 'white');
    w.style.position = 'absolute';
    w.style.left = (i * 60) + 'px';
    w.style.top = '0';
    w.dataset.note = k.note;       // playChord expects the note name (no octave)
    w.dataset.octave = k.octave;   // left for reference / possible future use
    w.innerHTML = `<div class="note-label">${k.note}${k.octave}</div>`;

    w.addEventListener('mousedown', () => {
      w.classList.add('playing');
      playChord(k.note);
    });
    w.addEventListener('mouseup', () => w.classList.remove('playing'));
    w.addEventListener('mouseleave', () => w.classList.remove('playing'));

    piano.appendChild(w);
  });

  // create black keys for each octave (absolute positioned between whites)
  // for octave 4 and 5
  for (let oIndex = 0; oIndex < 2; oIndex++) {
    const baseOctave = 4 + oIndex;
    for (let i = 0; i < blackPattern.length; i++) {
      const bn = blackPattern[i];
      if (!bn) continue;
      const whiteIndex = oIndex * 7 + i; // position after this white key
      const left = (whiteIndex * 60) + 45; // offset to place black key over gap
      const b = document.createElement('div');
      b.classList.add('key', 'black');
      b.style.position = 'absolute';
      b.style.left = left + 'px';
      b.style.top = '0px';
      b.dataset.note = bn;
      b.dataset.octave = baseOctave;
      b.innerHTML = `<div class="note-label">${bn}${baseOctave}</div>`;

      b.addEventListener('mousedown', () => {
        b.classList.add('playing');
        playChord(bn);
      });
      b.addEventListener('mouseup', () => b.classList.remove('playing'));
      b.addEventListener('mouseleave', () => b.classList.remove('playing'));

      piano.appendChild(b);
    }
  }
}
/* ---------------------------
   end createPiano
   --------------------------- */

document.getElementById("startAudio").addEventListener("click", async () => {
  if (!isStarted) {
    audioCtx = new AudioContext();
    isStarted = true;
    await preload();
    alert("피아노가 준비되었습니다!");
  }
});

document.getElementById("majorBtn").addEventListener("click", () => {
  scaleType = 'major';
  document.getElementById("majorBtn").classList.add("active");
  document.getElementById("minorBtn").classList.remove("active");
});

document.getElementById("minorBtn").addEventListener("click", () => {
  scaleType = 'minor';
  document.getElementById("minorBtn").classList.add("active");
  document.getElementById("majorBtn").classList.remove("active");
});

document.getElementById("code1Btn").addEventListener("click", () => {
  codeType = 1;
  document.getElementById("code1Btn").classList.add("active");
  document.getElementById("code2Btn").classList.remove("active");
});

document.getElementById("code2Btn").addEventListener("click", () => {
  codeType = 2;
  document.getElementById("code2Btn").classList.add("active");
  document.getElementById("code1Btn").classList.remove("active");
});

createPiano();
</script>
</body>
</html>
